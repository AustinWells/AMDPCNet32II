/*
 *
 * AMDPCNet32II.m -- driver for AMDPCNet32-II Network Device
 *
 * Created by Austin Wells 11/01/21
 */

#import <driverkit/i386/directDevice.h>
#import <driverkit/i386/IOPCIDeviceDescription.h>
#import <driverkit/i386/IOPCIDirectDevice.h>
#import <driverkit/i386/PCI.h>
#import <driverkit/i386/ioPorts.h>
#import <driverkit/generalFuncs.h>
#import <driverkit/kernelDriver.h>
#import <driverkit/align.h>
#import <kernserv/prototypes.h>

#import "AMDPCNet32II.h"
#import "PCNetIO.h"

/** 
    returns YES if this is owned by the driver
    returns NO if this is a free DE we can use
**/
BOOL driverOwn(char *RingBuffer, int idx) {
	if (RingBuffer[DE_SIZE * idx + 7] & 0x80) {
		return NO;
	} 
	else {
		return YES;
	}
}


@implementation AMDPCNet32II

+ (BOOL)probe:deviceDescription
{
    id driver;
   
    driver = [[self alloc] initFromDeviceDescription:deviceDescription];
    if (driver == nil)
	return NO;
    else return YES;

}

- (void)writeRAP16:(int)val {
  outw(ioBase+RAP16, val);  
}

- (void)writeRAP32:(long)val {
  outl(ioBase+RAP32, val);  
}

- (int)readCSR16:(int)csr_no { 

  [self writeRAP16: csr_no];
  return inw(ioBase + RDP16);

}

- (long)readCSR32:(long)csr_no { 

  [self writeRAP32: csr_no];
  return inl(ioBase + RDP32);

}

- (void)writeCSR16:(int)csr_no :(int)val { 

  [self writeRAP16: csr_no];
  return outw(ioBase + RDP16, val);

}

- (void)writeCSR32:(long)csr_no :(long)val { 

  [self writeRAP32: csr_no];
  return outl(ioBase + RDP32, val);

}

- (int)readBCR16:(int)bsr_no { 

  [self writeRAP16: bsr_no];
  return inw(ioBase + BDP16);

}

- (long)readBCR32:(long)bsr_no { 

  [self writeRAP32: bsr_no];
  return inl(ioBase + BDP32);

}

- (void)writeBCR16:(int)bsr_no :(int)val { 

  [self writeRAP16: bsr_no];
  return outw(ioBase + BDP16, val);

}

- (void)writeBCR32:(long)bsr_no :(long)val { 

  [self writeRAP32: bsr_no];
  return outl(ioBase + BDP32, val);

}

- initFromDeviceDescription:deviceDescription
{
  
    IOPCIConfigSpace config;
    IOPCIDeviceDescription *devDescription = (IOPCIDeviceDescription *)deviceDescription;	 

    ns_time_t start, end; 
    unsigned long conf;

    unsigned long csr58;
    unsigned long bcr2;

    //vm_address_t registerSetup;
    unsigned int *registerSetup;
    unsigned int *s;

    unsigned int i = 0;

    AMDPCNetRegisters initRegisters;

    IOReturn rc;

    if([IODirectDevice getPCIConfigSpace: &config withDeviceDescription: devDescription] != IO_R_SUCCESS) {
	IOLog("Can't get config space....\n");
	[self free];
	return nil;
    }
 
    // Need to enable bus mastering on the card
    [IODirectDevice getPCIConfigData: &conf atRegister: 0x1 withDeviceDescription: devDescription];

    IOLog("PCI Config: %lx\n", conf);

    conf &= 0xFFFF0000;
    conf |= 0x5;
 
    IOLog("PCI Config: %lx\n", conf);

    [IODirectDevice setPCIConfigData: conf atRegister: 0x1 withDeviceDescription: devDescription];

    IOLog("Bus Mastering Enabled\n");

    // At this point bus mastering should have been enabled

    ioBase = config.BaseAddress[0] & 0xfffe;
    irq = config.InterruptLine; 

    IOLog("AMDPCNet32II\n");
    IOLog("Vendor:%x\n", config.VendorID);
    IOLog("Device:%x\n", config.DeviceID);
    IOLog("Base:%x\n", ioBase);
    IOLog("Irq num: %x\n", irq);
    IOLog("Mac Addr: ");
    for(i = 0; i < 6; i++) {
    	mac[i] = inb(ioBase + i);
	IOLog("%02x ", mac[i]);
    }
    IOLog("\n");

    port.start = ioBase;
    port.size  = 32;

    [devDescription setPortRangeList: &port num: 1];
    [devDescription setInterruptList: &irq  num: 1];    

    if ([super initFromDeviceDescription:deviceDescription] == nil)
    	return nil;
    
    // Do a reset so we know the card is in 16bit mode
    IOLog("Resetting card ...\n");

    inl(ioBase + 0x18); //if 32bit
    inw(ioBase + 0x14); //if 16bit

    // Wait at least 1 usec for the card to come back
    IOLog("waiting for card to come back ...\n");    

    IOGetTimestamp(&start);
    while(1) {
       IOGetTimestamp(&end);
       if((end - start) > 1000)
           break;
    }
    IOLog("done\n");

    // We now must be in 16bit mode. 
    outl(ioBase + 0x10, 0);
    
    // Set SWStyle to 2
    csr58 = [self readCSR32: 58];
    csr58 &= 0xFF00;
    csr58 |= 0x2;
    [self writeCSR32: 58 : csr58];
    
    // Set ASEL 
    bcr2 = [self readBCR32: 2];
    bcr2 |= 0x2;
    [self writeBCR32: 2 : bcr2]; 


    // allocate 48 bytes so we can get it 32 byte aligned
    s = kalloc(64);
    registerSetup = IOAlign(void*, s, 32); //kmem_alloc_wired(IOVmtaskSelf(), s, 32);
    bzero(s, 64); // zero memory and ensure it has been accessed
    IOLog("vaddr: %x:%x\n", s, registerSetup);	 
    
    rc = IOPhysicalFromVirtual(IOVmTaskSelf(), registerSetup, s);
    if(rc == IO_R_INVALID_ARG)
	IOLog("FAILED TO GET PHYSICAL ADDRESS\n");
    else
        IOLog("phys: %x\n", *s);

    // Use hardcoded values for now
    
    initRegisters.TLEN = 3;
    initRegisters.RLEN = 3;
    initRegisters.MODE = 0;
    for(i = 0; i < 6; i++) {
    	initRegisters.MAC[i] = mac[i];
    }
    for(i = 0; i < 8; i++) {
    	initRegisters.LADR[i] = 0x00;
    }
    
    initRegisters.rxDescriptorAddr = 0x00;
    initRegisters.txDescriptorAddr = 0x00;

        
  
    return self; 
}
@end
